class Warding {
  int c1, c2, c3, c4;
  IntList pointX = new IntList();
  IntList pointY = new IntList();
  boolean finished = false;
  float mX, mY;
  float averageRadius = 0;
  int accuratePoints = 0;
  
  Warding(int c1, int c2, int c3, int c4) {
    this.c1 = c1;
    this.c2 = c2;
    this.c3 = c3;
    this.c4 = c4;
  }

  void storePoint(int x, int y) {
    pointX.append(x);
    pointY.append(y);
  }

  void display() {
    stroke(c1, c2, c3);
    strokeWeight(3);

    // Draw the stored shape
    for (int i = 1; i < pointX.size(); i++) {
     line(pointX.get(i - 1), pointY.get(i - 1), pointX.get(i), pointY.get(i));
    }
  
    // Draw the center point only if the shape is finished so no wonky
    if (finished) {
      drawCenter();
    }
  }

  void calc() {
    if (pointX.size() > 1 && pointY.size() > 1) {
      int lowX = pointX.min();
      int highX = pointX.max();
      int lowY = pointY.min();
      int highY = pointY.max();

      mX = (highX + lowX) / 2.0;
      mY = (highY + lowY) / 2.0;

      finished = true;  // Mark shape as completed so it doesn't go wonky

      // average radius from the first and last points
      float radius = dist(mX, mY, pointX.get(0), pointY.get(0));  // assumes the first point is on the circle's edge
      averageRadius = radius;  // Store it as the average radius

      // Calculate accuracy
      calculateAccuracy();

      println("lowX:", lowX, "highX:", highX, "lowY:", lowY, "highY:", highY);
      println("Calculated Center: mX =", mX, "mY =", mY);
      println("Average Radius:", averageRadius);
      println("Accurate Points:", accuratePoints);
      println("Accuracy:", getAccuracyPercentage());
    }
  }

  void drawCenter() {
    stroke(100);
    strokeWeight(10);
    point(mX, mY);
  }

  // average radius amd how many points have that or have almost that radius
  void calculateAccuracy() {
    float totalRadius = 0;
    float margin = 10;  // error margin allowed
    
    for (int i = 0; i < pointX.size(); i++) {
      float distToCenter = dist(mX, mY, pointX.get(i), pointY.get(i));
      totalRadius += distToCenter;
      
      // is it in margin?
      if (abs(distToCenter - averageRadius) <= margin) {
        accuratePoints++;
      }
    }

    averageRadius = totalRadius / pointX.size();  // average radius
  }
  
  float getAccuracyPercentage() {
    if (pointX.size() > 0) {
      return (accuratePoints / float(pointX.size())) * 100;
    } else {
      return 0;
    }
  }
}
